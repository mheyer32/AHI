\input iso.sty
\input texinfo             @c -*-texinfo-*-
@c %***start of header
@setfilename devguide.guide
@settitle @sc{Ahi} Developers's Guide, version @value{ahiver}
@setchapternewpage odd
@iftex
@afourpaper
@end iftex
@c %***end of header


@c $VER: ahidev.texinfo 4.2 (11.5.97)
@set ahiver 4.2

@c $Id$
@c $Log$
@c Revision 4.2  1997/05/11 12:38:39  lcs
@c Added note about unrolling short sounds.
@c
@c Revision 4.1  1997/05/04 15:52:15  lcs
@c Initial revision.
@c


@c Part 2: Summary Description and Copyright
@c ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

@ifinfo
This file documents AHI version @value{ahiver}, a hardware independent
audio system for Amiga.

Copyright @copyright{} 1994-1997 Martin Blom.  This publication may not be
modified in any way, including translation, without prior consent, in
writing, by the author.

Permission is granted to make and distribute verbatim copies of this manual
provided the copyright notice and this permission notice are preserved on
all copies.

THIS PUBLICATION IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
PUBLICATION, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

@end ifinfo

@c Part 3: Titlepage and Copyright
@c ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

@titlepage
@title AHI
@subtitle Hardware independent audio for Amiga
@subtitle AHI Developer's Guide, version @value{ahiver}
@author Martin 'Leviticus' Blom

@page

@vskip 0pt plus 1filll

Copyright @copyright{} 1994-1997 Martin Blom.  This publication may not be
modified in any way, including translation, without prior consent, in
writing, by the author.

Permission is granted to make and distribute verbatim copies of this manual
provided the copyright notice and this permission notice are preserved on
all copies.

@sc{This publication is provided by the author ``as is'' and any express or
implied warranties, including, but not limited to, the implied warranties
of merchantability and fitness for a particular purpose are disclaimed.  In
no event shall the author be liable for any direct, indirect, incidental,
special, exemplary, or consequential damages (including, but not limited
to, procurement of substitute goods or services; loss of use, data, or
profits; or business interruption) however caused and on any theory of
liability, whether in contract, strict liability, or tort (including
negligence or otherwise) arising in any way out of the use of this
publication, even if advised of the possibility of such damage.}

@end titlepage


@c Part 4: `Top' Node and Master Menu
@c ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

@node    Top, Overview, (dir), (dir)

@ifinfo

@majorheading @sc{Ahi} Developer's Guide, version @value{ahiver}

Copyright @copyright{} 1994-1997 Martin Blom

The latest release of @sc{Ahi} can always be found at
@url{http://www.lysator.liu.se/~lcs/ahi.html}. 

@menu
* Overview::                    Brief introduction
* Distribution::                What you are allowed to do and not
* The Author::                  Who designed it?

* Definitions::                 Terms used in this document
* Function Interface::          The low-level API
* Device Interface::            The high-level API
* Data Types And Structures::   The structures explained

* Concept Index::               Concept Index
* Data Type Index::             Data Type Index
* Function Index::              Function Index
* Variable Index::              Variable Index

 --- The Detailed Node Listing ---

Function Interface

* Guidelines::                  
* Opening And Closing ahi.device For Low-level Access::  
* Obtaining The Hardware::      
* Declaring Sounds::            
* Making Noise::                

Device Interface

* Opening And Closing ahi.device For High-level Access::  
* Reading From The Device::     
* Writing To The Device::       

Data Types And Structures

* Data Types::                  
* Structures::                  
@end menu

@end ifinfo


@c Part 5:  The Body of the Document
@c ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯


@c ***********************************************************************
@c **** Overview *********************************************************
@c ***********************************************************************

@node Overview, Distribution, Top, Top
@comment  node-name,  next,  previous,  up
@chapter Overview

@cindex Overview

This document was written in order to make it easier for developers to
understand and use @sc{Ahi} in their own productions, and write Software
That Works(TM).

@code{ahi.device} has two different API's; one library-like function
interface (low-level), and one ``normal'' device interface (high-level).
Each of them serves different purposes.  The low-level interface is
targeting music players, games and real-time applications. The high-level
interface is targeting applications that just want to have a sample played,
play audio streams or record samples as easily as possible.

As with everything else, it is important that you chose the right tool for
the job---you'll only get frustrated otherwise.

Not everything about @sc{Ahi} is documented here; for more information, see
@cite{@sc{Ahi} User's Guide} and the autodocs.


@c ***********************************************************************
@c **** Distribution *****************************************************
@c ***********************************************************************

@node  Distribution, The Author, Overview, Top
@comment  node-name,  next,  previous,  up
@chapter Distribution

@cindex Distribution
@cindex Disclaimer
@cindex License
@cindex Legal nonsense
@cindex Software license
@cindex Copyright

Copyright @copyright{} 1994-1997 Martin Blom

@sc{Ahi} is available as @dfn{freeware}.  That is, it may be freely
distributed in unmodified form with no changes what so ever, but you may
not charge more than a nominal fee covering distribution costs. However,
donations are welcome (see @cite{@sc{Ahi} User's Guide}).

If you use this software in a commercial or shareware product, please
consider giving the author (@pxref{The Author})---and preferably each one
of the contributors too (see @cite{@sc{Ahi} User's Guide})---an original or
registered version of your work.

If you wish to distribute this software with a hardware product, contact
the author (@pxref{The Author}).  Distribution of @sc{AHI} with hardware
products is @emph{not} free.

@sc{This software is provided by the author and contributors ``as is'' and any
express or implied warranties, including, but not limited to, the implied
warranties of merchantability and fitness for a particular purpose are
disclaimed.  In no event shall the author or contributors be liable for any
direct, indirect, incidental, special, exemplary, or consequential damages
(including, but not limited to, procurement of substitute goods or
services; loss of use, data, or profits; or business interruption) however
caused and on any theory of liability, whether in contract, strict
liability, or tort (including negligence or otherwise) arising in any way
out of the use of this software, even if advised of the possibility of such
damage.}



@c ***********************************************************************
@c **** The Author *******************************************************
@c ***********************************************************************

@node  The Author, Definitions, Distribution, Top
@comment  node-name,  next,  previous,  up
@chapter The Author

@cindex The Author
@cindex Author of @sc{Ahi}

The author can be reached at the following addresses:

@table @asis

@item Electronic mail
@email{lcs@@lysator.liu.se}

@item Standard mail
  Martin Blom
@*Alsättersgatan 15A:24
@*SE-584 35 Linköping
@*Sweden

@item World-Wide Web
@url{http://www.lysator.liu.se/~lcs}

@end table


@c ***********************************************************************
@c **** Definitions  *****************************************************
@c ***********************************************************************

@node Definitions, Function Interface, The Author, Top
@comment  node-name,  next,  previous,  up
@chapter Definitions

@cindex Definitions

Following are some general definitions of terms that are used in this
document.

@table @dfn

@cindex Sample

@item Sample
A sample is one binary number, representing the amplitude at a fixed point
in time.  A sample is often stored as an 8 bit signed integer, a 16 bit
signed integer, a 32 bit floating point number etc.  @sc{Ahi} only
supports integers.

@cindex Sample frame

@item Sample frame
In mono environments, a sample frame is the same as a sample.  In stereo
environments, a sample frame is a tuple of two samples.  The first member
is for the left channel, the second for the right.

@cindex Sound

@item Sound
Many sample frames stored in sequence as an array can be called a sound.  A
sound is, however, not limited to being formed by samples, it can also be
parameters to an analog synth or a MIDI instrument, or be white noise.
@sc{Ahi} only supports sounds formed by samples.

@end table


@c ***********************************************************************
@c ***********************************************************************
@c **** Function Interface ***********************************************
@c ***********************************************************************
@c ***********************************************************************

@node Function Interface, Device Interface, Definitions, Top
@comment  node-name,  next,  previous,  up
@chapter Function Interface

@cindex Function Interface

 The device has, in addition to the usual I/O request protocol, a set of
functions that allows the programmer to gain full control (at least as much
as possible with device independence) over the audio hardware.  The
advantages are low overhead and much more advanced control over the playing
sounds.  The disadvantages are greater complexity and only one user per
sound card.

@cindex Music, games
@cindex Sound effects, games
@cindex Games, music
@cindex Games, sound effects
@cindex Realtime effects
@cindex Recording, high quality

 If you want to play music or sound effects for a game, record in high
quality or want to do realtime effects, this is the API to use.



@menu
* Guidelines::                  
* Opening And Closing ahi.device For Low-level Access::  
* Obtaining The Hardware::      
* Declaring Sounds::            
* Making Noise::                
@end menu


@c ***********************************************************************
@c **** Guidelines *******************************************************
@c ***********************************************************************

@node Guidelines, Opening And Closing ahi.device For Low-level Access, Function Interface, Function Interface
@comment  node-name,  next,  previous,  up
@section Guidelines

@cindex Guidelines
@cindex Programming guidelines


@subsection Follow The Rules

 It's really simple.  If I tell you to check return values, check sample
types when recording, not to trash d2-d7/a2-a6 in hooks, or not to call
@code{AHI_ControlAudio()} with the @code{AHIC_Play} tag from interrupts or
hooks, you do as you are told.


@subsection The Library Base

@cindex Library base
@tindex AHIBase

 The @code{AHIBase} structure is private, so are the sub libraries' library
base structures.  Don't try to be clever.


@subsection The Audio Database

@cindex The Audio Database

@findex AHI_NextAudioID()
@findex AHI_GetAudioAttrsA()
@findex AHI_BestAudioIDA()

 The implementation of the database is private, and may change any time.
@code{ahi.device} provides functions access the information in the database
(@code{AHI_NextAudioID()}, @code{AHI_GetAudioAttrsA()} and
@code{AHI_BestAudioIDA()}).


@subsection User Hooks

@cindex Hooks

 All user hooks must follow normal register conventions, which means that
d2-d7 and a2-a6 must be preserved.  They may be called from an interrupt,
but you cannot count on that; it can be your own process or another
process.  Don't assume the system is in single-thread mode.  Never spend
much time in a hook, get the work done as quick as possible and then
return.


@subsection Function Calls From Other Tasks, Interrupts Or User Hooks

 The @code{AHIAudioCtrl} structure may not be shared with other
tasks/threads.  The task that called @code{AHI_AllocAudioA()} must do all
other calls too (except those callable from interrupts).

 Only calls specifically said to be callable from interrupts may be called
from user hooks or interrupts.  Note that @code{AHI_ControlAudioA()} has
some tags that must not be present when called from an interrupt.


@subsection Multitasking

@cindex Multitasking

 Most audio drivers need multitasking to be turned on to function properly.
Don't turn it off while using the device.



@c ***********************************************************************
@c **** Opening And Closing ahi.device For Low-level Access **************
@c ***********************************************************************

@node Opening And Closing ahi.device For Low-level Access, Obtaining The Hardware, Guidelines, Function Interface
@comment  node-name,  next,  previous,  up
@section Opening And Closing @code{ahi.device} For Low-level Access


 Not too hard.  Just open @code{ahi.device} unit @code{AHI_NO_UNIT} and
initialize @code{AHIBase}.  After that you can access all the functions of
the device just as if you had opened a standard shared library.


@subsection @code{Assembler}

 For the assembler programmer there are two handy macros: @code{OPENAHI}
and @code{CLOSEAHI}.  Here is a small example how to use them:

@example
        OPENAHI 4                  ;Open at least version 4.
        lea     _AHIBase(pc),a0
        move.l  d0,(a0)
        beq     error

; AHI's functions can now be called as normal library functions:
        move.l  _AHIBase(pc),a6
        moveq   #AHI_INVALID_ID,d0
        jsr     _LVOAHI_NextAudioID(a6)

error:
        CLOSEAHI
        rts
@end example


 Note that you @strong{have} to execute the @code{CLOSEAHI} macro even if
@code{OPENAHI} failed!


@subsection @code{C}

 For the C programmer, here is how it should be done:

@noindent
@example
struct Library    *AHIBase;
struct MsgPort    *AHImp=NULL;
struct AHIRequest *AHIio=NULL;
BYTE               AHIDevice=-1;

if(AHImp=CreateMsgPort())
@{
  if(AHIio=(struct AHIRequest *)CreateIORequest(
      AHImp,sizeof(struct AHIRequest)))
  @{
    AHIio->ahir_Version=4;  // Open at least version 4.
    if(!(AHIDevice=OpenDevice(AHINAME,AHI_NO_UNIT,
        (struct IORequest *)AHIio,NULL)))
    @{
      AHIBase=(struct Library *)AHIio->ahir_Std.io_Device;

// AHI's functions can now be called as normal library functions:
      AHI_NextAudioID(AHI_INVALID_ID);

      CloseDevice((struct IORequest *)AHIio);
      AHIDevice=-1; // Good habit, IMHO.
    @}
    DeleteIORequest((struct IORequest *)AHIio);
    AHIio=NULL;
  @}
  DeleteMsgPort(AHImp);
  AHImp=NULL;
@}
@end example



@c ***********************************************************************
@c **** Obtaining The Hardware *******************************************
@c ***********************************************************************

@node Obtaining The Hardware, Declaring Sounds, Opening And Closing ahi.device For Low-level Access, Function Interface
@comment  node-name,  next,  previous,  up
@section Obtaining The Hardware

 If you wish to call any other function than

@itemize @bullet

@item
@code{AHI_AllocAudioRequestA()}

@item
@code{AHI_AudioRequestA()}

@item
@code{AHI_BestAudioIDA()}

@item
@code{AHI_FreeAudioRequest()}

@item
@code{AHI_GetAudioAttrsA()}

@item
@code{AHI_NextAudioID()}

@item
@code{AHI_SampleFrameSize()}

@end itemize

@findex AHI_AllocAudioA()
@tindex AHIAudioCtrl
@vindex ahiac_UserData

@dots{}you have to allocate the actual sound hardware.  This is done with
@code{AHI_AllocAudioA()}.  @code{AHI_AllocAudioA()} returns an
@code{AHIAudioCtrl} structure, or @code{NULL} if the hardware could not be
allocated.  The @code{AHIAudioCtrl} structure has only one public field,
@code{ahiac_UserData}.  This is unused by @sc{Ahi} and you may store
anything you like here.

 If @code{AHI_AllocAudioA()} fails it is important that you handle the
situation gracefully.

@findex AHI_FreeAudio()

 When you are finished playing or recording, call @code{AHI_FreeAudio()} to
deallocate the hardware and other resources allocated by
@code{AHI_AllocAudioA()}.  @code{AHI_FreeAudio()} also deallocates all
loaded sounds (@pxref{Declaring Sounds}).


@subsection @code{AHI_AllocAudioA()} Tags

@code{AHI_AllocAudioA()} takes several tags as input.

@vtable @code

@vindex AHI_DEFAULT_ID

@item AHIA_AudioID
This is the audio mode to be used.  You must not use any hardcoded values
other than @code{AHI_DEFAULT_ID}, which is the user's default fallback ID.
In most cases you should ask the user for an ID code (with
@code{AHI_AudioRequestA()}) and then store the value in your settings file.

@vindex AHI_DEFAULT_FREQ

@item AHIA_MixFreq
This is the mixing frequency to be used.  The actual frequency will be
rounded to the nearest frequency supported by the sound hardware.  To find
the actual frequency, use @code{AHI_GetAudioAttrsA()}.  If omitted or
@code{AHI_DEFAULT_FREQ}, the user's preferred fallback frequency will be
used.  In most cases you should ask the user for a frequency (with
@code{AHI_AudioRequestA()}) and then store the value in your settings file.

@item AHIA_Channels
All sounds are played on a @dfn{channel}, and this tag selects how many you
wish to use.  In general it takes more CPU power the more channels you use
and the volume gets lower and lower.

@item AHIA_Sounds
You must tell @sc{Ahi} how many different sounds you are going to play.
@xref{Declaring Sounds} for more information.

@tindex AHISoundMessage
@vindex ahism_Channel

@item AHIA_SoundFunc
With this tag you tell @sc{Ahi} to call a hook when a sound has been
started.  It works just like Paula's audio interrupts.  The hook receives an
@code{AHISoundMessage} structure as message.
@code{AHISoundMessage->ahism_Channel} indicates which channel the sound
that caused the hook to be called is played on.

@item AHIA_PlayerFunc
If you are going to play a musical score, you should use this ``interrupt''
source instead of VBLANK or CIA timers in order to get the best result with
all audio drivers.  If you cannot use this, you must not use any
``non-realtime'' modes (see @code{AHI_GetAudioAttrsA()} in the autodocs,
the @code{AHIDB_Realtime} tag).

@item AHIA_PlayerFreq
If non-zero, it enables timing and specifies how many times per second
@code{PlayerFunc} will be called.  This must be specified if
@code{AHIA_PlayerFunc} is!  It is suggested that you keep the frequency
below 100-200 Hz.  Since the frequency is a fixpoint number
@code{AHIA_PlayerFreq} should be less than 13107200 (that's 200 Hz).

@item AHIA_MinPlayerFreq
The minimum frequency (@code{AHIA_PlayerFreq}) you will use.  You should
always supply this if you are using the device's interrupt feature!

@item AHIA_MaxPlayerFreq
The maximum frequency (@code{AHIA_PlayerFreq}) you will use.  You should
always supply this if you are using the device's interrupt feature!

@item AHIA_RecordFunc
This hook will be called regularly when sampling is turned on (see
@code{AHI_ControlAudioA()}).  It is important that you always check the
format of the sampled data, and ignore it if you can't parse it.  Since
this hook may be called from an interrupt, it is not legal to directly
@code{Write()} the buffer to disk.  To record directly to harddisk you
have to copy the samples to another buffer and signal a process to save it.
To find out the required size of the buffer, see
@code{AHI_GetAudioAttrsA()} in the autodocs, the
@code{AHIDB_MaxRecordSamples} tag.

@vindex ahiac_UserData

@item AHIA_UserData
Can be used to initialize the @code{ahiac_UserData} field.  You do not have
to use this tag to change @code{ahiac_UserData}, you may write to it
directly.

@end vtable

@c ***********************************************************************
@c **** Declaring Sounds *************************************************
@c ***********************************************************************

@node Declaring Sounds, Making Noise, Obtaining The Hardware, Function Interface
@comment  node-name,  next,  previous,  up
@section Declaring Sounds

@cindex Loading Sounds
@cindex Unloading Sounds

@findex AHI_LoadSound()

 Before you can play a sample array, you must @code{AHI_LoadSound()} it.
Why?  Because if @sc{Ahi} knows what kind of sounds that will be played
later, tables and stuff can be set up in advance.  Some drivers may even
upload the samples to the sound cards local RAM and play all samples from
there, drastically reducing CPU and bus load.

 @code{AHI_LoadSound()} also associates each sound or sample array with a
number, which is later used to refer to that particular sound.

 There are 2 types of sounds, namely @code{AHIST_SAMPLE} and
@code{AHIST_DYNAMICSAMPLE}.

@c and @code{AHIST_INPUT}.

@vtable @code

@item AHIST_SAMPLE
This is used for static samples.  Most sounds that will be played are of
this type.  Once the samples has been ``loaded'', you may not alter the
memory where the samples are located.  You may, however, read from it.

@item AHIST_DYNAMICSAMPLE
If you wish to play samples that you calculate in realtime, or load in
portions from disk, you must use this type.  These samples will never be
uploaded to a sound cards local RAM, but always played from the normal
memory.  There is a catch, however.  Because of the fact that the sound is
mixed in chunks, you must have a certain number of samples in memory before
you start a sound of this type.  To calculate the size of the buffer (in
samples), use the following formula:

@example
@math{size = samples * Fs / Fm}
@end example

where samples is the value returned from @code{AHI_GetAudioAttrsA()} when
called with the @code{AHIDB_MaxPlaySamples} tag, Fs is the highest
frequency the sound will be played at and Fm is the actual mixing frequency
(@code{AHI_ControlAudioA()/AHIC_MixFreq_Query}).


@c @item AHIST_INPUT
@c This sound type is used to use @sc{Ahi}'s DSP-effects in real-time.  [It
@c does not work yet. FIXIT]

@end vtable

@findex AHI_UnloadSound()

 If you know that you won't use a sound anymore, call
@code{AHI_UnloadSound()}.  @code{AHI_FreeAudio()} will also do that for you
for any sounds left when called.

 There is no need to place a sample array in @dfn{Chip memory}, but it
@strong{must not} be swapped out!  Allocate your sample memory with the
@code{MEMF_PUBLIC} flag set.  If you wish to have your samples in virtual
memory, you have to write a double-buffer routine that copies a chunk of
memory to a @code{MEMF_PUBLIC} buffer.  The @dfn{SoundFunc} should signal a
task to do the transfer, since it may run in supervisor mode (see
@code{AHI_AllocAudioA()}).


@c ***********************************************************************
@c **** Making Noise *****************************************************
@c ***********************************************************************

@node Making Noise,  , Declaring Sounds, Function Interface
@comment  node-name,  next,  previous,  up
@section Making Noise

@findex AHI_ControlAudioA()
@vindex AHIC_Play

After you have allocated the sound hardware and declared all your sounds,
you're ready to start playback.  This is done with a call to
@code{AHI_ControlAudioA()}, with the @code{AHIC_Play} tag set to
@code{TRUE}.  When this function returns the @dfn{PlayerFunc} (see
@code{AHI_AllocAudioA()}) is active, and the audio driver is feeding
silence to the sound hardware.

@subsection Playing A Sound

@findex AHI_SetSound()
@findex AHI_SetFreq()
@findex AHI_SetVol()

All you have to do now is to set the desired sound, it's frequency and
volume.  This is done with @code{AHI_SetSound()}, @code{AHI_SetFreq()} and
@code{AHI_SetVol()}.  Make sure the @code{AHISF_IMM} flag is set for all
these function's @var{flag} argument.  And don't try to modify a channel
that is out of range!  If you have allocated 4 channels you may only modify
channels 0-3.

The sound will not start until both @code{AHI_SetSound()} and
@code{SetFreq()} has been called.  The sound will play even if
@code{AHI_SetVol()} was not called, but it will play completely silent.  If
you wish to temporary stop a sound, set its frequency to 0.  When you
change the frequency again, the sound will continue where it were.

@findex AHI_PlayA()

When the sound has been started it will play to the end and then repeat.
In order to play a one-shot sound you have use the @code{AHI_PlayA()}
function, or install a sound interrupt using the @code{AHIA_SoundFunc} tag
with @code{AHI_AllocAudioA()}.  For more information about using sound
interrupts, see below.

A little note regarding @code{AHI_SetSound()}:  @var{Offset} is the first
sample that will be played, both when playing backwards and forwards.  This
means that if you call @code{AHI_SetSound()} with @var{offset} 0 and
@var{length} 4, sample 0,1,2 and 3 will be played.  If you call
@code{AHI_SetSound()} with @var{offset} 3 and @var{length} @minus{}4,
sample 3,2,1 and 0 will be played.

Also note that playing very short sounds will be very CPU intensive, since
there are many tasks that must be done each time a sound has reached its
end (like starting the next one, calling the @dfn{SoundFunc}, etc.).
Therefore, it is recommended that you ``unroll'' short sounds a couple of
times before you play them.  How many times you should unroll?  Well, it
depends on the situation, of course, but try making the sound a thousand
samples long if you can. Naturally, if you need your @dfn{SoundFunc} to
be called, you cannot unroll.

@subsection Playing One-shot Sounds And Advanced Loops

@vindex AHISF_IMM

 Some changes has been made since earlier releases.  One-shot sounds and
sounds with only one loop segment can now be played without using sample
interrupts.  This is possible because one of the restrictions regarding the
@code{AHISF_IMM} flag has been removed.

 The @code{AHISF_IMM} flag determines if @code{AHI_SetSound()},
@code{AHI_SetFreq()} and @code{AHI_SetVol()} should take effect immediately
or when the current sound has reached its end.  The rules for this flags
are:

@itemize @bullet

@item
If used inside a sample interrupt (@dfn{SoundFunc}):  Must be cleared.

@item
If used inside a player interrupt (@dfn{PlayerFunc}):  May be set or
cleared.

@item
If used elsewhere:  Must be set.

@end itemize

 What does this mean?  It means that if all you want to do is to play a
one-shot sound from inside a @dfn{PlayerFunc}, you can do that by first
calling @code{AHI_SetSound()}, @code{AHI_SetFreq()} and @code{AHI_SetVol()}
with @code{AHISF_IMM} set, and then use @code{AHI_SetSound(ch, AHI_NOSOUND,
0, 0, actrl, 0L)} to stop the sound when it has reached the end.  You can
also set one loop segment this way.

 @code{AHI_PlayA()} was added in @sc{Ahi} version 4, and combines
@code{AHI_SetSound()}, @code{AHI_SetFreq()} and @code{AHI_SetVol()} into
one tag-based function.  It also allows you to set one loop and play
one-shot sounds.

 To play a sound with more than one loop segment or ping-pong looping, a
sample interrupt needs to be used.  @sc{Ahi}'s @dfn{SoundFunc} works like Paula's
interrupts and is very easy to use.

 The @dfn{SoundFunc} hook will be called with an @code{AHIAudioCtrl}
structure as object and an @code{AHISoundMessage} structure as message.
@code{ahism_Channel} indicates which channel caused the hook to be called.

 An example @dfn{SoundFunc} which handles the repeat part of an instrument
can look like this (SAS/C code):

@example
__asm __saveds ULONG SoundFunc(register __a0 struct Hook *hook,
    register __a2 struct AHIAudioCtrl *actrl,
    register __a1 struct AHISoundMessage *chan)
@{
  if(ChannelDatas[chan->ahism_Channel].Length)
    AHI_SetSound(chan->ahism_Channel,0,
        (ULONG) ChannelDatas[chan->ahism_Channel].Address,
        ChannelDatas[chan->ahism_Channel].Length,
        actrl,NULL);
  else
    AHI_SetSound(chan->ahism_Channel,AHI_NOSOUND,
        NULL,NULL,actrl,NULL);
  return NULL;
@}
@end example


 This example is from an old version of the @sc{Ahi} NotePlayer for
@dfn{DeliTracker 2}.  @code{ChannelDatas} is an array where the start and
length of the repeat part is stored.  Here, a repeat length of zero
indicates a one-shot sound.  Note that this particular example only uses
one sound (0).  For applications using multiple sounds, the sound number
would have to be stored in the array as well.

 Once again, note that the @code{AHISF_IMM} flag should @strong{never} be
set in a @dfn{SoundFunc} hook!


@subsection Tricks With The Volume

@cindex Surround sound

 Starting with V4, @code{AHI_SetVol()} can take both negative volume and
pan parameters.  If you set the volume to a negative value, the sample
will, if the audio mode supports it, invert each sample before playing.  If
pan is negative, the sample will be encoded to go to the surround speakers.



@c ***********************************************************************
@c ***********************************************************************
@c **** Device Interface *************************************************
@c ***********************************************************************
@c ***********************************************************************

@node Device Interface, Data Types And Structures, Function Interface, Top
@comment  node-name,  next,  previous,  up
@chapter Device Interface

@cindex Music, streams from disk
@cindex Playing audio streams
@cindex Audio streams, playing
@cindex Sound effects, system
@cindex Recording, quick and easy

 The I/O request protocol makes it very easy to play audio streams, sounds
from disk and non time-critical sound effects in a multitasking friendly
way.  Recoding is just as easy, on behalf of quality.  Several programs can
play sounds at the same time, and even record at the same time if your
hardware is full duplex.

 If you want to write a sample player, play (warning?) sounds in your
applications, play an audio stream from a CD via the SCSI/IDE bus, write a
voice command utility etc., this is the API to use.

 Note that while all the low-level functions (@pxref{Function Interface})
count lengths and offsets in sample frames, the device interface---like all
Amiga devices---uses bytes.


@c ***********************************************************************
@c **** Opening And Closing ahi.device For High-level Access *************
@c ***********************************************************************

@menu
* Opening And Closing ahi.device For High-level Access::  
* Reading From The Device::     
* Writing To The Device::       
@end menu

@node Opening And Closing ahi.device For High-level Access, Reading From The Device, Device Interface, Device Interface
@comment  node-name,  next,  previous,  up
@section Opening And Closing @code{ahi.device} For High-level Access

 Four primary steps are required to open ahi.device:

@itemize @bullet

@item
Create a message port using @code{CreateMsgPort()}.  Reply messages from
the device must be directed to a message port.

@tindex AHIRequest

@item
Create an extended I/O request structure of type @code{AHIRequest} using
@code{CreateIORequest()}.  @code{CreateIORequest()} will initialize the I/O
request to point to your reply port.

@item
Specify which version of the device you need.  The lowest supported version
is 4.  Version 1 and 3 are obsolete, and version 2 only has the low-level
API.

@vindex AHI_DEFAULT_UNIT

@item
Open @code{ahi.device} unit @code{AHI_DEFAULT_UNIT} or any other unit the
user has specified with, for example, a @var{UNIT} tooltype.  Call
@code{OpenDevice()}, passing the I/O request.

@end itemize

 Each @code{OpenDevice()} must eventually be matched by a call to
@code{CloseDevice()}.  When the last close is performed, the device will
deallocate all resources.

 All I/O requests must be completed before @code{CloseDevice()}.  Abort any
pending requests with @code{AbortIO()}.

 Example:

@example
struct MsgPort    *AHImp      = NULL;
struct AHIRequest *AHIio      = NULL;
BYTE               AHIDevice  = -1;
UBYTE              unit       = AHI_DEFAULT_UNIT;

/* Check if user wants another unit here... */

if(AHImp = CreateMsgPort())
@{
  if(AHIio = (struct AHIRequest *)
      CreateIORequest(AHImp, sizeof(struct AHIRequest)))
  @{
    AHIio->ahir_Version = 4;
    if(!(AHIDevice = OpenDevice(AHINAME, unit, 
        (struct IORequest *)AHIio, NULL)))
    @{


      /* Send commands to the device here... */


      if(! CheckIO((struct IORequest *)AHIio))
      @{
        AbortIO((struct IORequest *)AHIio);
      @}

      WaitIO((struct IORequest *)AHIio);

      CloseDevice((struct IORequest *)AHIio);
      AHIDevice = -1;
    @}
    DeleteIORequest((struct IORequest *)AHIio);
    AHIio = NULL;
  @}
  DeleteMsgPort(AHImp);
  AHImp = NULL;
@}
@end example



@c ***********************************************************************
@c **** Reading From The Device ******************************************
@c ***********************************************************************

@node Reading From The Device, Writing To The Device, Opening And Closing ahi.device For High-level Access, Device Interface
@comment  node-name,  next,  previous,  up
@section Reading From The Device

@cindex Reading
@cindex Recording

@vindex CMD_READ
@vindex io_Command
@vindex io_Length
@vindex io_Data
@vindex ahir_Type
@vindex ahir_Frequency
@vindex io_Length
@vindex io_Offset

 You read from @code{ahi.device} by passing an @code{AHIRequest} to the
device with @code{CMD_READ} set in @code{io_Command}, the number of bytes
to be read set in @code{io_Length}, the address of the read buffer set in
@code{io_Data}, the desired sample format set in @code{ahir_Type} and the
desired sample frequency set in @code{ahir_Frequency}.  The first read
command in a sequence should also have @code{io_Offset} set to 0.
@code{io_Length} must be an even multiple of the sample frame size.

@subsection Double Buffering

@cindex Double Buffering, reading

 To do double buffering, just fill the first buffer with @code{DoIO()} and
@code{io_Offset} set to 0, then start filling the second buffer with
@code{SendIO()} using the same I/O request (but don't clear
@code{io_Offset}!).  After you have processed the first buffer, wait until
the I/O request is finished and start over with @code{SendIO()} on the
first buffer.

@subsection Distortion

@cindex Distortion, recording

 The samples will automatically be converted to the sample format set in
@code{ahir_Type} and to the sample frequency set in @code{ahir_Frequency}.
Because it is quite unlikely that you ask for the same sample frequency the
user has chosen in the preference program, chances that the quality is
lower than expected are pretty high.  The worst problem is probably the
anti-aliasing filter before the A/D converter.  If the user has selected a
higher sampling/mixing frequency than you request, the signal will be
distorted according to the Nyquist sampling theorem.  If, on the other
hand, the user has selected a lower sampling/mixing frequency than you
request, the signal will not be distorted but rather bandlimited more than
necessary.


@c ***********************************************************************
@c **** Writing To The Device ********************************************
@c ***********************************************************************

@node Writing To The Device,  , Reading From The Device, Device Interface
@comment  node-name,  next,  previous,  up
@section Writing To The Device

@cindex Writing
@cindex Playing

@vindex CMD_WRITE
@vindex io_Command
@vindex ln_Pri
@vindex io_Length
@vindex io_Data
@vindex ahir_Type
@vindex ahir_Frequency
@vindex ahir_Volume
@vindex ahir_Position
@vindex ahir_Link
@vindex io_Length


 You write to the device by passing an @code{AHIRequest} to the device with
@code{CMD_WRITE} set in @code{io_Command}, the precedence in
@code{io_Message.mn_Node.ln_Pri}, the number of bytes to be written in
@code{io_Length}, the address of the write buffer set in @code{io_Data},
the sample format set in @code{ahir_Type}, the desired sample frequency set
in @code{ahir_Frequency}, the desired volume set in @code{ahir_Volume} and
the desired stereo position set in @code{ahir_Position}.  Unless you are
doing double buffering, @code{ahir_Link} should be set to @code{NULL}.
@code{io_Length} must be an even multiple of the sample frame size.

@subsection Double Buffering

@cindex Double Buffering, writing

 To do double buffering, you need two I/O requests.  Create the second one
by making a copy of the request you used in @code{OpenDevice()}.  Start the
first with @code{SendIO()}.  Set @code{ahir_Link} in the second request to
the address of the first request, and @code{SendIO()} it.  Wait on the
first, fill the first buffer again and repeat, this time with
@code{ahir_Link} of the first buffer set to the address of the second I/O
request.

@subsection Distortion

@cindex Distortion, playing

 The problems with aliasing are present but not as obvious as with reading.
Just make sure your source data is bandlimited correctly, and do not play
samples at a lower frequency than they were recorded.

@subsection Playing multiple sounds at the same time

 If you want to play several sounds at the same time, just make a new copy
of the I/O request you used in @code{OpenDevice()}, and @code{CMD_WRITE}
it.  The user has set the number of channels available in the preference
tool, and if too many requests are sent to the device the one with lowest
precedence will be muted.  When a request is finished, the muted request
with the highest precedence will be played.  Note that all muted requests
continue to play silently, so the programmer will not have to worry if
there are enough channels or not.

@subsection Suggested precedences

@cindex Precedences

 The precedences to use depend on what kind of sound you are playing.  The
recommended precedences are the same as for @code{audio.device}, listed in
@cite{AMIGA ROM Kernel Reference manual -- Devices}.  Reprinted without
permission.  So sue me.

@example
 Precedences  | Type of sound
 -------------+----------------------------------------------------------
    127       |  Unstoppable.  Sounds first allocated at lower
              | precedencies, then set to this highest level.
    90 - 100  |  Emergencies.  Alert, urgent situation that requires
              | immediate action.
    80 - 90   |  Annunciators.  Attention, bell (CTRL-G).
    75        |  Speech.  Synthesized or recorded speech
              | (narrator.device).
    50 - 70   |  Sonic cues.  Sounds that provide information that is not
              | provided by graphics.  Only the beginning of of each sound
              | should be at this level; the rest should ne set to sound
              | effects level.
   -50 - 50   |  Music program.  Musical notes in a music-oriented program.
              | The higher levels should be used for the attack portions
              | of each note.
   -70 - -50  |  Sound effects.  Sounds used in conjunction with graphics.
              | More important sounds should use higher levels.
   -100 - -80 |  Background.  Theme music and restartable background sounds.
   -128       |  Silence.  Lowest level (freeing the channel completely is
              | preferred).
@end example

@c @multitable @columnfractions .15 .75
@c 
@c @item Precedences @tab Type of sound
@c 
@c @item 127
@c @tab Unstoppable.  Sounds first allocated at lower precendencies, then set
@c to this highest level.
@c 
@c @item 90 - 100
@c @tab Emergencies.  Alert, urgent situation that requires immediate action.
@c 
@c @item 80 - 90
@c @tab Annunciators.  Attention, bell (CTRL-G).
@c 
@c @item 75
@c @tab Speech.  Synthesized or recorded speech (narrator.device).
@c 
@c @item 50 - 70
@c @tab Sonic cues.  Sounds that provide information that is not
@c provided by graphics.  Only the beginning of of each sound
@c should be at this level; the rest should ne set to sound
@c effects level.
@c 
@c @item @minus{}50 - 50
@c @tab Music program.  Musical notes in a music-oriented program.  The higher
@c levels should be used for the attack portions of each note.
@c 
@c @item @minus{}70 - @minus{}50
@c @tab  Sound  effects.   Sounds  used  in  conjunction  with graphics.  More
@c important sounds should use higher levels.
@c 
@c @item @minus{}100 - @minus{}80
@c @tab Background.  Theme music and restartable background sounds.
@c 
@c @item @minus{}128
@c @tab Silence.  Lowest level (freeing the channel completely is preferred).
@c 
@c @end multitable

 Right.  As you can see, some things do not apply to @code{ahi.device}.
First, there is no way to change the precedence of a playing sound, so the
precedences should be set from the beginning.  Second, it is not
recommended to use the device interface to play music.  However, playing an
audio stream from CD or disk comes very close.  Third, there are no channels
to free in @sc{Ahi} since they are dynamically allocated by the device.


@c ***********************************************************************
@c ***********************************************************************
@c **** Data Types And Structures ****************************************
@c ***********************************************************************
@c ***********************************************************************

@node Data Types And Structures, Concept Index, Device Interface, Top
@comment  node-name,  next,  previous,  up
@chapter Data Types And Structures

@cindex Data Types And Structures

 In this chapter some of the data types and structures used will be
explained.  For more information, please consult the autodocs and the
include files.


@c ***********************************************************************
@c **** Data Types *******************************************************
@c ***********************************************************************

@menu
* Data Types::                  
* Structures::                  
@end menu

@node Data Types, Structures, Data Types And Structures, Data Types And Structures
@comment  node-name,  next,  previous,  up
@section Data Types

@cindex Data Types

@subsection @code{Fixed}

@tindex Fixed

 @code{Fixed} is a signed long integer.  It is used to represent decimal
numbers without using floating point arithmetics.  The decimal point is
assumed to be in the middle of the 32 bit integer, thus giving 16 bits for
the integer part of the number and 16 bits for the fraction.  The largest
number that can be stored in a @code{Fixed} is +32767.999984741, and the
lowest number is @minus{}32768.

 Example:

@example
 Decimal | Fixed
 --------+----------
  1.0    | 0x00010000
  0.5    | 0x00008000
  0.25   | 0x00004000
  0      | 0x00000000
 -0.25   | 0xffffc000
 -0.5    | 0xffff8000
 -1.0    | 0xffff0000
@end example

@subsection @code{sposition}

@tindex sposition

 @code{sposition} (stereo position) is a @code{Fixed}, and is used to
represent the stereo position of a sound.  0 is far left, 0.5 is center and
1.0 is far right.


@c ***********************************************************************
@c **** Structures *******************************************************
@c ***********************************************************************

@node Structures,  , Data Types, Data Types And Structures
@comment  node-name,  next,  previous,  up
@section Structures

@cindex Structures

@subsection @code{AHIUnitPrefs} And @code{AHIGlobalPrefs}

@tindex AHIUnitPrefs
@tindex AHIGlobalPrefs

 These structures are used in the @code{AHIU} and @code{AHIG} chunks,
respective, which are part of the settings file (@file{ENV:Sys/ahi.prefs}),
The file is read by @sc{Ahi} on each call to @code{OpenDevice()}, just
before the audio hardware is allocated.

 @code{AHIUnitPrefs} specifies the audio mode and its parameters to use for
each device unit (currently 0-3 and @code{AHI_NO_UNIT}; unit 0 is also called
@code{AHI_DEFAULT_UNIT}).

 @code{AHIGlobalPrefs} contains some global options that can be used to
gain speed on slow CPUs, the global debug level and a protection against
CPU overload.  The debug level specifies which of the functions in @sc{Ahi}
should print debugging information to the serial port (the output can be
redirected to a console window or a file with tools like @dfn{Sushi}
@footnote{Available from AmiNet, for example @*
@url{ftp://ftp.germany.aminet.org/pub/aminet/dev/debug/Sushi.lha}.}).






@c Part 6: The End of the Document
@c ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

@c ***********************************************************************
@c **** Concept Index ****************************************************
@c ***********************************************************************

@node Concept Index, Data Type Index, Data Types And Structures, Top
@unnumbered Concept Index

@cindex Recursion

@printindex cp


@c ***********************************************************************
@c **** Data Type Index **************************************************
@c ***********************************************************************

@node Data Type Index, Function Index, Concept Index, Top
@unnumbered Data Type Index

@printindex tp


@c ***********************************************************************
@c **** Function Index ***************************************************
@c ***********************************************************************

@node Function Index, Variable Index, Data Type Index, Top
@unnumbered Function Index

@printindex fn


@c ***********************************************************************
@c **** Variable Index ***************************************************
@c ***********************************************************************

@node Variable Index,  , Function Index, Top
@unnumbered Variable Index

@printindex vr


@c ***********************************************************************
@c **** Contents *********************************************************
@c ***********************************************************************

@contents
@bye
